package com.sdyedu.poly_.Detail_;
/*
 *   多态的前提是: 两个对象(类)存在继承关系
 *   多态的向上转型
 *   1) 本质: 父类的引用指向了子类的对象
 *   2) 语法: 父类类型 引用名 = new 子类类型()
 *   3) 特点: 编译类型看左边, 运行类型看右边
 *   4) 可以调用父类中的所有成员(需遵守访问权限), 不能调用子类中特有成员, 最终运行结果看子类的具体实现
 * */
public class PolyDetail {
    public static void main(String[] args) {
        // 向上转型: 父类的引用指向了子类的对象
        // 语法: 父类类型 引用名 = new 子类类型()
        Animal animal = new Cat();  // 本来是猫, 向上转型成为动物
        /*
        *   调用规则:
        *   可以调用父类中的所有成员(需遵守访问权限), 不能调用子类中特有成员
        *   因为在编译阶段, 能调用哪些成员, 是由编译类型来决定的
        *   所以 eat 可以调用, catchMouse 无法调用
        *
        *   最终运行效果看子类(运行类型)的具体实现, 既调用方法时, 按照从子类(运行类型)开始查找方法
        *   然后调用, 规则和我们前面讲的方法调用规则一致(先找子类, 再找父类)
        * */
        animal.eat(); // 猫吃鱼
        animal.run();
        animal.sleep();
        // animal.catchMouse(); // 错误

        /*
         *  希望调用 Cat 的 catchMouse方法
         *  多态的向下转型: 其实是一个还原的过程
         *  1) 语法: 子类类型 引用名 = (子类类型) 父类引用
         *  2) 只能强转父类的引用, 不能强转父类的对象
         *  3) 要求父类的引用必须指向的是当前目标类型的对象
         *  4) 当向下转型后, 可以调用子类类型中所有的成员
         *
         * 注意事项:
         *  1) 必须保证对象本来创建的时候就是猫, 才能向下转型成为猫, 例如 animal 在new 的时候就是 Cat, 才能转换为 Cat
         *  2) 如果对象创建的时候本来不是猫(狗), 现在非要向下转型成为猫(狗), 就会报错
         * */

        //
        // cat 的 编译类型是 Cat, 运行类型是 Cat
        Cat cat = (Cat) animal; // 本来是猫, 已经被当做动物了,还原回来成为本来的猫
        cat.catchMouse();

        // 这是不对的
        // 如果对象创建的时候本来不是狗), 现在非要向下转型成为狗, 就会报错(ClassCastException)
        Dog dog = (Dog) animal;
    }

}
